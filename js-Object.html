<!DOCTYPE html>
<html>
<head>
    <title>RequireJs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <!--<script src="js/require.js" data-main="js/config.js"></script>-->
    <style>
        body{
            background-color: #333;
        }
        p {
            display: block;
            border: 1px solid #000;
            padding: 48px;
            left: 50%;
            /*width: 200px;
            margin-left: -100px;*/
            position: absolute;
            height: 48px;
            line-height: 48px;
            text-align: center;
            color:#fff;
            background-color: #f0f;
            /*transform: translateX(-50%);*/
            top: 50%;
            transform: translate(-50%,-50%);
        }
    </style>
</head>
<body>
<p id="pps">
    居中布局
</p>
<input value="test" id="input1" style="display: none">

<h2 style="display: none">Great Web resources</h2>
<ul id="resources" style="display: none">
    <li><a href="http://opera.com/wsc">Opera Web Standards Curriculum</a></li>
    <li><a href="http://sitepoint.com">Sitepoint</a></li>
    <li><a href="http://alistapart.com">A List Apart</a></li>
    <li><a href="http://yuiblog.com">YUI Blog</a></li>
    <li><a href="http://caibaojian.com">WEB frontend blog</a></li>
    <li><a href="http://www.devtoutiao.com">Develop news</a></li>
</ul>

<script>
    /*
    var person = new Object();
    person.name = "Nicholas";
    person.age = 29;
    person.job = "Software Engineer";
    person.sayName = function(){
        alert(this.name);
    };
    */
    /*
    var person = {
        name: "Nicholas",
        age: 29,
        job: "Software Engineer",
        sayName: function(){
            alert(this.name);
        }
    };
    person.sayName();
    */
    /*
    要修改属性默认的特性，必须使用ECMAScript 5 的Object.defineProperty()方法。这个方法
    接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属
    性必须是：configurable、enumerable、writable 和value。设置其中的一或多个值，可以修改
    对应的特性值。例如：
    */
    /*
    var person = {};
    Object.defineProperty(person, "name", {
        writable: false,
        value: "Nicholas"
    });
    alert(person.name); //"Nicholas"
    person.name = "Greg";
    alert(person.name); //"Nicholas"
    */

    /*
    function Person(name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function(){
            alert(this.name);
        };
    }
    var person1 = new Person("Nicholas", 29, "Software Engineer");
    var person2 = new Person("Greg", 27, "Doctor");
    alert(typeof person1);
//    在前面例子的最后，person1 和person2 分别保存着Person 的一个不同的实例。这两个对象都
//    有一个constructor（构造函数）属性，该属性指向Person，如下所示。
    alert(person1.constructor == Person);
    alert(person2.constructor == Person); //true
//    对象的constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是instanceof
//    操作符要更可靠一些。我们在这个例子中创建的所有对象既是Object 的实例，同时也是Person
//    的实例，这一点通过instanceof 操作符可以得到验证。
    alert(person1 instanceof Object); //true
    alert(person1 instanceof Person); //true
    alert(person2 instanceof Object); //true
    alert(person2 instanceof Person); //true
    */

    /*
    1. 将构造函数当作函数
    构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不
    存在定义构造函数的特殊语法。任何函数，只要通过new 操作符来调用，那它就可以作为构造函数；而
    任何函数，如果不通过new 操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义
    的Person()函数可以通过下列任何一种方式来调用。
    */
    // 当作构造函数使用
    /*
    function Person(name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function(){
            alert(this.name);
        };
    }
    var person = new Person("Nicholas", 29, "Software Engineer");
    person.sayName(); //"Nicholas"
    // 作为普通函数调用
    Person("Greg", 27, "Doctor"); // 添加到window
    window.sayName(); //"Greg"
    // 在另一个对象的作用域中调用
    var o = new Object();
    Person.call(o, "Kristen", 25, "Nurse");
    o.sayName(); //"Kristen"
    */

    /*
    6.2.3 原型模式
    我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，
    而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那
    么prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以
    让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是
    可以将这些信息直接添加到原型对象中，如下面的例子所示。
    */
    /*
    function Person(){
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
        alert(this.name);
    };
    var person1 = new Person();
    person1.sayName(); //"Nicholas"
    var person2 = new Person();
    person2.sayName(); //"Nicholas"
    alert(person1.sayName == person2.sayName); //true
    alert(Person.prototype.isPrototypeOf(person1)); //true
    alert(Person.prototype.isPrototypeOf(person2)); //true
    alert(Object.getPrototypeOf(person1) == Person.prototype); //true
    console.log(Object.getPrototypeOf(person1));
    alert(Object.getPrototypeOf(person1).name); //"Nicholas"
    */

    /*
    function Person(){
    }

    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
        alert(this.name);
    };
    var person1 = new Person();
    var person2 = new Person();
    person1.name = "Greg";
    alert(person1.name); //"Greg"——来自实例
    alert(person2.name); //"Nicholas"——来自原型
    */

//    使用delete 操作符则可以完全删
//    除实例属性，从而让我们能够重新访问原型中的属性，如下所示。
    /*
    function Person(){
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
        alert(this.name);
    };
    var person1 = new Person();
    var person2 = new Person();
    person1.name = "Greg";
    alert(person1.name); //"Greg"——来自实例
    alert(person2.name); //"Nicholas"——来自原型
    delete person1.name;
    alert(person1.name); //"Nicholas"——来自原型
    */

//    使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不
//    要忘了它是从Object 继承来的）只在给定属性存在于对象实例中时，才会返回true。来看下面这个例子。
    /*
    function Person(){
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
        alert(this.name);
    };
    var person1 = new Person();
    var person2 = new Person();
    alert(person1.hasOwnProperty("name")); //false
    person1.name = "Greg";
    alert(person1.name); //"Greg"——来自实例
    alert(person1.hasOwnProperty("name")); //true
    alert(person2.name); //"Nicholas"——来自原型
    alert(person2.hasOwnProperty("name")); //false
    delete person1.name;
    alert(person1.name); //"Nicholas"——来自原型
    alert(person1.hasOwnProperty("name")); //false
    */


//    有两种方式使用in 操作符：单独使用和在for-in 循环中使用。在单独使用时，in 操作符会在通
//    过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。看一看下面的例子。
    /*
    function Person(){
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
        alert(this.name);
    };
    var person1 = new Person();
    var person2 = new Person();
    alert(person1.hasOwnProperty("name")); //false
    alert("name" in person1); //true
    person1.name = "Greg";
    alert(person1.name); //"Greg" ——来自实例
    alert(person1.hasOwnProperty("name")); //true
    alert("name" in person1); //true
    alert(person2.name); //"Nicholas" ——来自原型
    alert(person2.hasOwnProperty("name")); //false
    alert("name" in person2); //true
    delete person1.name;
    alert(person1.name); //"Nicholas" ——来自原型
    alert(person1.hasOwnProperty("name")); //false
    alert("name" in person1); //true
    */
//    同时使用hasOwnProperty()方法和in 操作符，就可以确定该属性到底是存在于对象中，还是存在于
//    原型中，如下所示。
    /*
    function hasPrototypeProperty(object, name){
        return !object.hasOwnProperty(name) && (name in object);
    }
//    由于in 操作符只要通过对象能够访问到属性就返回true，hasOwnProperty()只在属性存在于
//    实例中时才返回true，因此只要in 操作符返回true 而hasOwnProperty()返回false，就可以确
//    定属性是原型中的属性。下面来看一看上面定义的函数hasPrototypeProperty()的用法。
    function Person(){
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
        alert(this.name);
    };
    var person = new Person();
    alert(hasPrototypeProperty(person, "name")); //true
    person.name = "Greg";
    alert(hasPrototypeProperty(person, "name")); //false
    */
    /*
    var o = {
        toString : function(){
            return "My Object";
        }
    };
    for (var prop in o){
        if (prop == "toString"){
            alert("Found toString"); //在IE 中不会显示
        }
    }
    */

//    要取得对象上所有可枚举的实例属性，可以使用ECMAScript 5 的Object.keys()方法。这个方法
//    接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。例如：
    /*
    function Person(){
    }
    Person.prototype.name = "Nicholas";
    Person.prototype.age = 29;
    Person.prototype.job = "Software Engineer";
    Person.prototype.sayName = function(){
        alert(this.name);
    };
    var keys = Object.keys(Person.prototype);
    alert(keys); //"name,age,job,sayName"
    var p1 = new Person();
    p1.name = "Rob";
    p1.age = 31;
    var p1keys = Object.keys(p1);
    alert(p1keys); //"name,age"
//    如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()
//    方法。
    var keys = Object.getOwnPropertyNames(Person.prototype);
    alert(keys); //"constructor,name,age,job,sayName"
    */

//    重设constructor 属性会导致它的[[Enumerable]]特性被设置为true。默认
//    情况下，原生的constructor 属性是不可枚举的，因此如果你使用兼容ECMAScript 5 的JavaScript 引
//    擎，可以试一试Object.defineProperty()。
    /*
    function Person(){
    }
    Person.prototype = {
        name : "Nicholas",
        age : 29,
        job : "Software Engineer",
        sayName : function () {
            alert(this.name);
        }
    };
    //重设构造函数，只适用于ECMAScript 5 兼容的浏览器
    Object.defineProperty(Person.prototype, "constructor", {
        enumerable: false,
        value: Person
    });

    */
//    创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实
//    例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，
//    但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参
//    数；可谓是集两种模式之长。下面的代码重写了前面的例子。
    function Person(name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.friends = ["Shelby", "Court"];
    }
    Person.prototype = {
        constructor : Person,
        sayName : function(){
            alert(this.name);
        }
    }
    var person1 = new Person("Nicholas", 29, "Software Engineer");
    var person2 = new Person("Greg", 27, "Doctor");
    person1.friends.push("Van");
    alert(person1.friends); //"Shelby,Count,Van"
    alert(person2.friends); //"Shelby,Count"
    alert(person1.friends === person2.friends); //false
    alert(person1.sayName === person2.sayName); //true
</script>
</body>
</html>
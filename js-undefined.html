<!DOCTYPE html>
<html>
<head>
    <title>RequireJs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <!--<script src="js/require.js" data-main="js/config.js"></script>-->
    <style>
        body{
            background-color: #333;
        }
        p {
            display: block;
            border: 1px solid #000;
            padding: 48px;
            left: 50%;
            /*width: 200px;
            margin-left: -100px;*/
            position: absolute;
            height: 48px;
            line-height: 48px;
            text-align: center;
            color:#fff;
            background-color: #f0f;
            /*transform: translateX(-50%);*/
            top: 50%;
            transform: translate(-50%,-50%);
        }
    </style>
</head>
<body>
<p id="pps">
    居中布局
</p>
<input value="test" id="input1" style="display: none">

<h2 style="display: none">Great Web resources</h2>
<ul id="resources" style="display: none">
    <li><a href="http://opera.com/wsc">Opera Web Standards Curriculum</a></li>
    <li><a href="http://sitepoint.com">Sitepoint</a></li>
    <li><a href="http://alistapart.com">A List Apart</a></li>
    <li><a href="http://yuiblog.com">YUI Blog</a></li>
    <li><a href="http://caibaojian.com">WEB frontend blog</a></li>
    <li><a href="http://www.devtoutiao.com">Develop news</a></li>
</ul>

<script>
    /*
    var message; // 这个变量声明之后默认取得了undefined 值
    // 下面这个变量并没有声明
    // var age
    alert(message); // "undefined"
    alert(age); // 产生错误
    */

    /*
    var car = null;
    alert(typeof car); // "object"
    */

    /*
    var num6 = parseFloat("3.125e7"); //31250000
    alert(num6);
    */
    /*
    var o = {
        valueOf: function() {
            return -1;
        }
    };
     //o=+o;
     alert(o);
     */
/*
    var i = 0;
    do {
        i += 2;
    } while (i < 10);
    alert(i);
    for (var propName in window) {
        document.write(propName+'\n');
    }
*/


    /*
    var num = 0;
    //console.log(num);
    outermost:
            for (var i=0; i < 10; i++) {
                for (var j=0; j < 10; j++) {
                    console.group("第" +i+"组信息");
                    console.log(i);
                    console.log(j);
                    console.groupEnd();
                    if (i == 5 && j == 5) {
//                        console.group("第" +i+"组信息");
//                        console.log(i);
//                        console.log(j);
//                        console.groupEnd();
                        break outermost;
                    }
                    num++;
                }
            }
    alert(num); //55
*/

    /*
    function sayHi(name, message) {
        alert("Hello " + name + "," + message);
    }
    sayHi("Nicholas", "how are you today?");
    */

//    我们为该对象添加了一个名为
//    name 的属性，并将字符串值"Nicholas"赋给了这个属性。紧接着，又通过alert()函数访问了这个
//    新属性。如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。
    /*var person = new Object();
    person.name = "Nicholas";
    alert(person.name); //"Nicholas"
    */


    /*
    function setName(obj) {
        obj.name = "Nilo";
    }
    var person = new Object();
    setName(person);
    alert(person.name); //"Nicholas"
*/

    console.group("typeof检测类型信息");
        var s = "Nicholas";
        var b = true;
        var i = 22;
        var u;
        var n = null;
        var o = new Object();
        console.log(typeof s); //string
        console.log(typeof i); //number
        console.log(typeof b); //boolean
        console.log(typeof u); //undefined
        console.log(typeof n); //object
        console.log(typeof o); //object
    console.groupEnd();

    /*
    var color = "blue";
    function changeColor(){
        if (color === "blue"){
            color = "red";
        } else {
            color = "blue";
        }
    }
    changeColor();
    alert("Color is now " + color);
*/
    var color = "blue";
    function changeColor(){
        var anotherColor = "red";
        function swapColors(){
            var tempColor = anotherColor;
            anotherColor = color;
            color = tempColor;
            // 这里可以访问color、anotherColor 和tempColor
        }
        // 这里可以访问color 和anotherColor，但不能访问tempColor
        swapColors();
    }
    // 这里只能访问color
    changeColor();
    console.log(color);
/*
    function buildUrl() {
        var qs = "?debug=true";
        with(location){
            var url = href + qs;
        }
        console.log(url);
        return url;
    }
    buildUrl();
*/

//    声明变量
//    使用var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部
//    环境；在with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用var 声明，该变量会自
//    动被添加到全局环境。如下所示：
    /*
    function add(num1, num2) {
        var sum = num1 + num2;
        return sum;
    }
    var result = add(10, 20); //30
    alert(sum); //由于sum 不是有效的变量，因此会导致错误
    */
//    ExecutionContextExample04.htm
//    以上代码中的函数add()定义了一个名为sum 的局部变量，该变量包含加法操作的结果。虽然结
//    果值从函数中返回了，但变量sum 在函数外部是访问不到的。如果省略这个例子中的var 关键字，那
//    么当add()执行完毕后，sum 也将可以访问到：
    /*
    function add(num1, num2) {
        sum = num1 + num2;
        return sum;
    }
    var result = add(10, 20); //30
    alert(sum); //30
    */

/*
    function displayInfo(args) {
        var output = "";
        if (typeof args.name == "string"){
            output += "Name: " + args.name + "\n";
        }
        if (typeof args.age == "number") {
            output += "Age: " + args.age + "\n";
        }
        alert(output);
    }
    displayInfo({
        name: "Nicholas",
        age: 29
    });
    displayInfo({
        name: "Greg"
    });
*/
    /*
    var colors = ["red", "blue", "green"]; // 创建一个包含3 个字符串的数组
    alert(colors.toString()); // red,blue,green
    alert(colors.valueOf()); // red,blue,green
    alert(colors); // red,blue,green
    */

//    ECMAScript 为数组专门提供了push()和pop()方法，以便
//    实现类似栈的行为。
//    push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而
//    pop()方法则从数组末尾移除最后一项，减少数组的length 值，然后返回移除的项。请看下面的例子：
    /*
    var colors = new Array(); // 创建一个数组
    var count = colors.push("red", "green"); // 推入两项
    alert(count); //2
    count = colors.push("black"); // 推入另一项
    alert(count); //3
    var item = colors.pop(); // 取得最后一项
    alert(item); //"black"
    alert(colors.length); //2
    */

    /*
    var numbers = [1,2,3,4,5,4,3,2,1];
    alert(numbers.indexOf(4)); //3
//    alert(numbers.lastIndexOf(4)); //5
//    alert(numbers.indexOf(4, 4)); //5
//    alert(numbers.lastIndexOf(4, 4)); //3
    var person = { name: "Nicholas" };
    var people = [{ name: "Nicholas" }];
    var morePeople = [person];
//    alert(people.indexOf(person)); //-1
//    alert(morePeople.indexOf(person)); //0
    */
//    迭代方法
//    ECMAScript 5 为数组定义了5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和
//    （可选的）运行该函数的作用域对象——影响this 的值。传入这些方法中的函数会接收三个参数：数
//    组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能
//    会也可能不会影响方法的返回值。以下是这5 个迭代方法的作用。
//     every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
//     filter()：对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的数组。
//     forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
//     map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
//     some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
//    以上方法都不会修改数组中的包含的值。
//    在这些方法中，最相似的是every()和some()，它们都用于查询数组中的项是否满足某个条件。
//    对every()来说，传入的函数必须对每一项都返回true，这个方法才返回true；否则，它就返回
//    false。而some()方法则是只要传入的函数对数组中的某一项返回true，就会返回true。请看以下
//    例子。

    /*
    var numbers = [1,2,3,4,5,4,3,2,1];
    var everyResult = numbers.every(function(item, index, array){
        return (item > 2);
    });
    alert(everyResult); //false
    var someResult = numbers.some(function(item, index, array){
        return (item > 2);
    });
    alert(someResult); //true
    */

//    使用reduce()方法可以执行求数组中所有值之和的操作，比如：
    /*
    var values = [1,2,3,4,5];
    var sum = values.reduce(function(prev, cur, index, array){
        console.log("prev:"+prev);
        console.log("cut:"+cur);
        return prev + cur;
    });
    alert(sum); //15
*/
//    ArrayReductionExample01.htm
//    第一次执行回调函数，prev 是1，cur 是2。第二次，prev 是3（1 加2 的结果），cur 是3（数组
//    的第三项）。这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。

//    var now = new Date();
//    alert(now); //15
    /*var someDate = new Date(Date.parse("May 25, 2004"));
    alert(someDate); //15
    */

    /*
    var re = null,
            i;
    for (i=0; i < 10; i++){
        re = /cat/g;
        re.test("catastrophe");
    }
    for (i=0; i < 10; i++){
        re = new RegExp("cat", "g");
        re.test("catastrophe");
    }
    */

    /*
    var pattern1 = /\[bc\]at/i;
    alert(pattern1.global); //false
    alert(pattern1.ignoreCase); //true
    alert(pattern1.multiline); //false
    alert(pattern1.lastIndex); //0
    alert(pattern1.source); //"\[bc\]at"
    var pattern2 = new RegExp("\\[bc\\]at", "i");
    alert(pattern2.global); //false
    alert(pattern2.ignoreCase); //true
    alert(pattern2.multiline); //false
    alert(pattern2.lastIndex); //0
    alert(pattern2.source); //"\[bc\]at"
    */

    /*
    var text = "mom and dad and baby";
    var pattern = /mom( and dad( and baby)?)?/gi;
    var matches = pattern.exec(text);
    alert(matches.index); // 0
    alert(matches.input); // "mom and dad and baby"
    alert(matches[0]); // "mom and dad and baby"
    alert(matches[1]); // " and dad and baby"
    alert(matches[2]); // " and baby"
    */

//    对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不
//    设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设
//    置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，如下面的例子所示。
    //****************************//
    /*
    var text = "cat, bat, sat, fat";
    var pattern1 = /.at/;
    var matches = pattern1.exec(text);
    alert(matches.index); //0
    alert(matches[0]); //cat
    alert(pattern1.lastIndex); //0
    matches = pattern1.exec(text);
    alert(matches.index); //0
    alert(matches[0]); //cat
    alert(pattern1.lastIndex); //0
    var pattern2 = /.at/g;
    var matches = pattern2.exec(text);
    alert(matches.index); //0
    alert(matches[0]); //cat
    alert(pattern2.lastIndex); //3
    matches = pattern2.exec(text);
    alert(matches.index); //5
    alert(matches[0]); //bat
    alert(pattern2.lastIndex); //8
    */
    /*
    var text = "000-00-0000";
    var pattern = /\d{3}-\d{2}-\d{4}/;
    if (pattern.test(text)){
        alert("The pattern was matched.");
    }
    */
/*
    var re = null,
            i;
    for (i=0; i < 10; i++){
        re = /cat/g;
        console.log(re.test("catastrophe"));
    }
    for (i=0; i < 10; i++){
        re = new RegExp("cat", "g");
        console.log(re.test("catastrophe"));
    }
*/
    /*
     * 注意：Opera 不支持input、lastMatch、lastParen 和multiline 属性
     * Internet Explorer 不支持multiline 属性
     */
    /*
    var text = "this has been a short summer";
    var pattern = /(.)hort/g;

    if (pattern.test(text)){
        console.log(RegExp.input); // this has been a short summer
        console.log(RegExp.leftContext); // this has been a
        console.log(RegExp.rightContext); // summer
        console.log(RegExp.lastMatch); // short
        console.log(RegExp.lastParen); // s
        console.log(RegExp.multiline); // false
    }
    */

    /*
    if (pattern.test(text)){
        alert(RegExp.$_); // this has been a short summer
        alert(RegExp["$`"]); // this has been a
        alert(RegExp["$'"]); // summer
        alert(RegExp["$&"]); // short
        alert(RegExp["$+"]); // s
        alert(RegExp["$*"]); // false
    }
    */
    function callSomeFunction(someFunction, someArgument){
        return someFunction(someArgument);
    }
    function add10(num){
        return num + 10;
    }
    var result1 = callSomeFunction(add10, 10);
    alert(result1); //20
    function getGreeting(name){
        return "Hello, " + name;
    }
    var result2 = callSomeFunction(getGreeting, "Nicholas");
    alert(result2); //"Hello, Nicholas"
</script>
</body>
</html>
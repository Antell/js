<!DOCTYPE html>
<html>
<head>
    <title>RequireJs</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <!--<script src="js/require.js" data-main="js/config.js"></script>-->
    <style>
        body{
            background-color: #333;
        }
        p {
            display: block;
            border: 1px solid #000;
            padding: 48px;
            left: 50%;
            /*width: 200px;
            margin-left: -100px;*/
            position: absolute;
            height: 48px;
            line-height: 48px;
            text-align: center;
            color:#fff;
            background-color: #f0f;
            /*transform: translateX(-50%);*/
            top: 50%;
            transform: translate(-50%,-50%);
        }
    </style>
</head>
<body>
<p id="pps">
    居中布局
</p>
<input value="test" id="input1" style="display: none">

<h2 style="display: none">Great Web resources</h2>
<ul id="resources" style="display: none">
    <li><a href="http://opera.com/wsc">Opera Web Standards Curriculum</a></li>
    <li><a href="http://sitepoint.com">Sitepoint</a></li>
    <li><a href="http://alistapart.com">A List Apart</a></li>
    <li><a href="http://yuiblog.com">YUI Blog</a></li>
    <li><a href="http://caibaojian.com">WEB frontend blog</a></li>
    <li><a href="http://www.devtoutiao.com">Develop news</a></li>
</ul>

<script>
    //作为值的函数
    /*
    function callSomeFunction(someFunction, someArgument){
        return someFunction(someArgument);
    }
    function add10(num){
        return num + 10;
    }
    var result1 = callSomeFunction(add10, 10);
    alert(result1); //20
    function getGreeting(name){
        return "Hello, " + name;
    }
    var result2 = callSomeFunction(getGreeting, "Nicholas");
    alert(result2); //"Hello, Nicholas"
    */

    //从一个函数中返回另一个函数，这也是极为有用的一种技术
    /*
    function createComparisonFunction(propertyName) {
        return function(object1, object2){
            var value1 = object1[propertyName];
            console.log("Value1:"+value1);
            var value2 = object2[propertyName];
            console.log("Value2:"+value2);
            if (value1 < value2){
                return -1;
            } else if (value1 > value2){
                return 1;
            } else {
                return 0;
            }
        };
    }
    var data = [{name: "zz", age: 28}, {name: "bb", age: 29}];
    data.sort(createComparisonFunction("name"));
    alert(data[0].name); //Nicholas
//    var data = [{name: "Zachary", age: 28}, {name: "Nicholas", age: 29}];
//    data.sort(createComparisonFunction("name"));
//    alert(data[0].name); //Nicholas

//    data.sort(createComparisonFunction("age"));
//    alert(data[0].name); //Zachary
    console.log(data);
    */

    //中文字排序
    /*
    var testArray = ["脚","本","之","家"];
    document.write(testArray.sort(
            function compareFunction(param1,param2){
                return param1.localeCompare(param2);  //output:之,家,本,脚
            }
    ));*/


    //callee
    /*
    function factorial(num){
        if (num <=1) {
            return 1;
        } else {
            return num * arguments.callee(num-1)
        }
    }
//    FunctionTypeArgumentsExample01.htm
//    在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用
//    函数时使用的是什么名字，都可以保证正常完成递归调用。例如：
    var trueFactorial = factorial;
    factorial = function(){
        return 0;
    };
    alert(trueFactorial(5)); //120
    alert(factorial(5));
    */

//    函数内部的另一个特殊对象是this，其行为与Java 和C#中的this 大致类似。换句话说，this
//    引用的是函数据以执行的环境对象——或者也可以说是this 值（当在网页的全局作用域中调用函数时，
//    this 对象引用的就是window）。来看下面的例子。
    /*
    window.color = "red";
    var o = { color: "blue" };
    function sayColor(){
        alert(this.color);
    }
    sayColor(); //"red"
    o.sayColor = sayColor;
    o.sayColor(); //"blue"
    */

    /*
    function outer(){
        inner();
    }
    function inner(){
        alert(arguments.callee.caller);
    }
    outer();
    */


//    事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数
//    赖以运行的作用域。下面来看一个例子。
    /*
    window.color = "red";
    var o = { color: "blue" };
    function sayColor(){
        alert(this.color);
    }
    sayColor(); //red
    sayColor.call(this); //red
    sayColor.call(window); //red
    sayColor.call(o); //blue
    */

//    ECMAScript 5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this 值会被绑
//    定到传给bind()函数的值。例如：
    /*
    window.color = "red";
    var o = { color: "blue" };
    function sayColor(){
        alert(this.color);
    }
    var objectSayColor = sayColor.bind(o);
    objectSayColor(); //blue
*/
    var stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";
    var positions = new Array();
    var pos = stringValue.indexOf("e");
    while(pos > -1){
        positions.push(pos);
        pos = stringValue.indexOf("e", pos + 1);
        //console.log(positions);
    }
    alert(positions); //"3,24,32,35,52"
</script>
</body>
</html>